/*
Command qstest generates test functions for graph.QuadStore implementations.
*/
package main

import (
	"bufio"
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"strings"
	"text/template"
)

func init() {
	log.SetFlags(0)
}

// QSTestImportPath is the default import path for qstest.
var QSTestImportPath = "github.com/bmatsuo/cayley/graph/graphtest/qstest"

// QSTestImportPath is the default name qstest is referred.
var QSTestPkg = "qstest"

func main() {
	opt := &Options{}
	flag.StringVar(&opt.ImplName, "impl", "", "A graph.QuadStore implementation to use with a default test runner.")
	flag.StringVar(&opt.RunnerName, "runner", "", "Test runner for the qstest test suite.")
	flag.StringVar(&opt.PkgName, "pkg", "", "Package name for the generated file.  A value is detected if not provided.")
	flag.StringVar(&opt.OutputPath, "output", "qstest_test.go", "destination test source file (will be overwritten).")
	flag.Parse()

	if opt.RunnerName == "" {
		log.Fatal("no runner name provided")
	}

	var err error

	pkg := opt.PkgName
	if pkg == "" {
		pkg, err = FindPkgName(".")
		if err != nil {
			log.Fatal(err)
		}
	}

	context := &TemplateContext{}
	context.Package = pkg
	context.Runner = opt.RunnerName
	context.Tests = AllTests
	context.Imports, err = buildImports(context.Tests)
	if err != nil {
		log.Fatalf("import error: %v", err)
	}

	if context.QSTest.Pkg == "" {
		context.QSTest.Pkg = QSTestPkg
	}
	if context.QSTest.ImportPath == "" {
		context.QSTest.ImportPath = QSTestImportPath
	}

	templates, err := template.New("").Funcs(context.Funcs()).Parse(RawTemplates)
	if err != nil {
		log.Fatal("template error", err)
	}

	f, err := os.Create(opt.OutputPath)
	if err != nil {
		log.Fatal(err)
	}
	err = templates.ExecuteTemplate(f, "suite", context)
	f.Close()
	if err != nil {
		log.Fatal(err)
	}

	cmd := exec.Command("gofmt", "-w", opt.OutputPath)
	p, err := cmd.CombinedOutput()
	if err != nil {
		log.Fatalf("gofmt (%v): %s", err, p)
	}
}

// Options is the set of command line options.
type Options struct {
	OutputPath string
	PkgName    string
	ImplName   string
	RunnerName string
	QSTest     struct {
		Pkg        string
		ImportPath string
	}
}

// Import represents an import statement.
type Import struct {
	PkgName string
	Path    string
}

// TemplateContext contains the set of data available to a template.
type TemplateContext struct {
	Package string
	Runner  string
	QSTest  struct {
		Pkg        string
		ImportPath string
	}
	Imports []*Import
	Tests   []*Test
}

func buildImports(test []*Test) ([]*Import, error) {
	seen := map[string]bool{}
	var imports []*Import
	for _, test := range AllTests {
		ipath := test.Import
		if ipath == "" {
			// tests in package scope
			continue
		}
		if seen[ipath] {
			continue
		}
		seen[ipath] = true

		name := path.Base(ipath)
		if name == "" {
			return nil, fmt.Errorf("bad import path: %v", ipath)
		}

		impt := &Import{
			Path:    ipath,
			PkgName: name,
		}
		imports = append(imports, impt)
	}
	return imports, nil
}

// Funcs returns a set of functions that can be used during template execution.
func (c *TemplateContext) Funcs() template.FuncMap {
	return map[string]interface{}{
		"selectfn": c.codeSelectFn,
	}
}

func (c *TemplateContext) codeSelectFn(ipath, fname string) (string, error) {
	var impt *Import
	for _, _impt := range c.Imports {
		if _impt.Path == ipath {
			impt = _impt
			break
		}
	}
	if impt == nil {
		return "", fmt.Errorf("unknown package")
	}
	sel := impt.PkgName + "." + fname
	return sel, nil
}

// RawTemplates defines the templates for running qstest tests.
const RawTemplates = `
{{define "suite"}}
// DO NOT MODIFY THIS FILE
// This file was autogenerated.
{{with $dot := .}}

package {{.Package}}

import (
	"testing"

	{{range $i, $import := .Imports}}
	{{$import.PkgName}} {{$import.Path | printf "%q"}}
	{{end}}
)

func init() {
	// TODO: setup default test runner if necessary.
}
{{range $i, $test := .Tests}}

func {{$test.Name}}(t *testing.T) {
	({{$dot.Runner}}).Run(t, {{$test.Name | printf "%q"}}, {{selectfn $test.Import $test.Name}})
}
{{end}}
{{end}}
{{end}}
`

// FindPkgName returns the name of the Go package in dir.
func FindPkgName(dir string) (string, error) {
	var pkg string
	pattern := filepath.Join(dir, "*.go")
	files, err := filepath.Glob(pattern)
	if err != nil {
		return "", err
	}
	for _, path := range files {
		_pkg, err := findPkgNameFile(path)
		if err != nil {
			return "", err
		}
		if pkg == "" {
			pkg = _pkg
		} else if pkg != _pkg {
			return "", fmt.Errorf("multiple package names declared: %s", dir)
		}
	}
	return pkg, nil
}

// BUG(bmatsuo):
// Package detection is flawed it does not build an ast or attempt to ignore comments.
func findPkgNameFile(path string) (string, error) {
	f, err := os.Open(path)
	if err != nil {
		return "", err
	}
	defer f.Close()

	s := bufio.NewScanner(f)
	for s.Scan() {
		ln := s.Text()
		if !strings.HasPrefix(ln, "package ") {
			continue
		}
		fields := strings.Fields(ln)
		if len(fields) != 2 {
			// not a valid package declaration.  maybe in a block comment.
			continue
		}
		return fields[1], nil
	}
	err = s.Err()
	if err != nil {
		return "", err
	}

	return "", fmt.Errorf("unable to find package delaration: %v", path)
}
